
单例模式我们可以提供出8种写法:

SingletonDemo1     饿汉式（静态常量）
SingletonDemo2     饿汉式（静态代码块）（可用）
SingletonDemo3     懒汉式（线程不安全，不推荐的方案）
SingletonDemo4     懒汉式（线程安全 ,性能差，不推荐）
SingletonDemo5     懒汉式（线程不安全 ,不推荐）
SingletonDemo6     懒汉式（volatile双重检查模式,推荐）
SingletonDemo7     静态内部类方式，可用
SingletonDemo8     枚举单例

饿汉式单例的含义是：在获取单例对象之前对象已经创建完成了。
懒汉式单例是指：在真正需要单例的时候才创建出该对象。

静态内部类:JVM在类初始化阶段（即在Class被加载后，且线程使用之前），会执行类的初始化。在执行类的初始
化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。


1.懒汉模式（线程安全）:虽然起到延迟加载的效果，但是锁会占用很多资源。
延迟加载（lazy load）主要是为了避免加载对象的同时加载其关联的对象，
避免无畏的开销，当我们真正需要数据的时候，才真正的执行加载。

2.饿汉模式：没有起到懒加载的效果。

3.静态类内部加载：静态内部类不会在单例加载时就加载，而是在调用
getInstance()方法时才进行加载，达到了类似懒汉模式的效果，而这种
方法又是线程安全的。

4.使用 Java 枚举的单例模式示例（充满美感的代码）

5.双重校验锁法
STEP 1. 线程A访问getInstance()方法，因为单例还没有实例化，所以进入了锁定块。
STEP 2. 线程B访问getInstance()方法，因为单例还没有实例化，得以访问接下来代码块，而接下来代码块已经被线程1锁定。
STEP 3. 线程A进入下一判断，因为单例还没有实例化，所以进行单例实例化，成功实例化后退出代码块，解除锁定。
STEP 4. 线程B进入接下来代码块，锁定线程，进入下一判断，因为已经实例化，退出代码块，解除锁定。
STEP 5. 线程A初始化并获取到了单例实例并返回，线程B获取了在线程A中初始化的单例。
理论上双重校验锁法是线程安全的，并且，这种方法实现了lazyloading。
